# Boilerplate Documentation

## 1. Overview

Simple and type-safe web application boilerplate built on **Next.js 16 (App Router)**. It prioritizes developer experience through end-to-end type safety and modular architecture.

**Key Technologies:**
*   **Framework:** Next.js 16
*   **Styling:** Tailwind CSS (with `shadcn/ui` patterns)
*   **Database/ORM:** Postgres with Drizzle ORM
*   **API:** tRPC (v11) with React Query
*   **Auth:** Better-Auth
*   **I18n:** next-intl

---

## 2. Core Concepts

### A. Database & Schema (Drizzle ORM)
The project uses **Drizzle ORM** connected to a PostgreSQL database.
*   **Configuration:** `drizzle.config.ts` controls migration generation.
*   **Connection:** `src/db/index.ts` instantiates the client. It uses a global singleton in development to prevent connection exhaustion during hot-reloading.
*   **Schema:** Defined in `src/db/schema/`. Tables are exported as TypeScript objects.
    *   `auth-schema.ts`: Contains Better-Auth required tables (User, Session, Account, Verification).
    *   `index.ts`: Aggregates all schema definitions.

### B. Authentication (Better-Auth)
Authentication is handled by **Better-Auth**, utilizing Drizzle as the adapter.
*   **Server Config:** `src/lib/better-auth/auth.ts`. Handles providers (Google, Magic Link) and email sending (Resend).
*   **Client Config:** `src/lib/better-auth/auth-client.ts`. Exports `authClient` for React components.
*   **Middleware/Protection:**
    *   **Route Protection:** `src/proxy.ts` acts as a middleware. It checks for `better-auth.session_token` cookies and handles redirects (e.g., pushing unauthenticated users from `/dashboard` to `/login`).
    *   **API Protection:** tRPC middleware (`isAuthed`) in `src/server/api/trpc.ts` ensures API requests are authenticated.

### C. API Layer (tRPC)
The application uses **tRPC** to create a type-safe API without manually defining REST endpoints.
*   **Router Definition:** Located in `src/server/api/routers/`.
*   **Root Router:** `src/server/api/root.ts` merges all sub-routers into `appRouter`.
*   **Procedures:** Defined in `src/server/api/trpc.ts`.
    *   `publicProcedure`: Accessible by anyone.
    *   `protectedProcedure`: Requires a valid session.
*   **Client Usage:** `src/lib/trpc/client.tsx` provides the `trpc` hook for Client Components.
*   **Server Usage:** `src/lib/trpc/server.ts` allows calling procedures directly in Server Components (RSC).

### D. Internationalization (next-intl)
*   **Locale Config:** `src/config/locales.ts` defines supported languages (en, fr).
*   **Messages:** JSON files stored in `src/messages/{locale}.json`.
*   **Detection:** `src/lib/i18n-config.ts` detects locale via cookies or headers.
*   **Switching:** `src/hooks/use-language-switcher.ts` sets the locale cookie.

### E. Environment Variables
Type-safe environment variables are enforced using `@t3-oss/env-nextjs` in `src/config/env.ts`. The app will fail to build if required keys are missing.

---

## 3. Use Cases & Workflows

### Use Case 1: Adding or Modifying a Database Schema

To add a new entity (e.g., a "Post" for a blog), follow this workflow:

1.  **Define Schema:**
    Create or edit a file in `src/db/schema/`.

    ```typescript
    // src/db/schema/post.ts
    import { pgTable, text, timestamp } from 'drizzle-orm/pg-core';
    import { user } from './auth-schema';

    export const post = pgTable('post', {
        id: text('id').primaryKey(),
        title: text('title').notNull(),
        content: text('content'),
        authorId: text('author_id').references(() => user.id),
        createdAt: timestamp('created_at').defaultNow()
    });
    ```

2.  **Export Schema:**
    Ensure the new table is exported in `src/db/schema/index.ts`.

3.  **Generate & Migrate:**
    Run the Drizzle Kit commands to update the database.

    ```bash
    npm run db:generate  # Creates SQL migration file in /drizzle
    npm run db:migrate   # Applies SQL to the actual database
    ```

4.  **Access in Code:**
    ```typescript
    import { db } from '@/db';
    import { post } from '@/db/schema';

    await db.insert(post).values({ ... });
    ```

---

### Use Case 2: Creating a Protected Route & Consuming it

To create a new feature that fetches data only for logged-in users:

1.  **Create tRPC Router:**
    Create `src/server/api/routers/project-router.ts`.

    ```typescript
    import { createTRPCRouter, protectedProcedure } from '@/server/api/trpc';
    import { z } from 'zod';

    export const projectRouter = createTRPCRouter({
        create: protectedProcedure
            .input(z.object({ name: z.string() }))
            .mutation(async ({ ctx, input }) => {
                // ctx.user is guaranteed to exist here
                return await ctx.db.insert(project).values({
                    name: input.name,
                    userId: ctx.user.id
                });
            }),

        getAll: protectedProcedure.query(async ({ ctx }) => {
            return await ctx.db.query.project.findMany({
                where: (table, { eq }) => eq(table.userId, ctx.user.id)
            });
        })
    });
    ```

2.  **Register Router:**
    Add to `src/server/api/root.ts`.

    ```typescript
    export const appRouter = createTRPCRouter({
        test: testRouter,
        project: projectRouter // <--- Added here
    });
    ```

3.  **Consume in Client Component:**
    Use the auto-generated hooks.

    ```tsx
    // src/app/(app)/projects/page.tsx
    'use client';
    import { trpc } from '@/lib/trpc/client';

    export default function ProjectsPage() {
        const { data, isLoading } = trpc.project.getAll.useQuery();
        const createMutation = trpc.project.create.useMutation({
            onSuccess: () => {
                // Invalidate query to refetch list
                utils.project.getAll.invalidate();
            }
        });

        if (isLoading) return <div>Loading...</div>;

        return (
            <div>
                {data?.map(p => <div key={p.id}>{p.name}</div>)}
                <button onClick={() => createMutation.mutate({ name: "New Project" })}>
                    Add
                </button>
            </div>
        );
    }
